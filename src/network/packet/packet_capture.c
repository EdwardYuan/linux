/*

net-newbie.com/tcpip/packets.html

TCP Packet

"struct ether_header {}" + 
	"struct iphder {}" + 
		"data"

*/

/***********************************************
ソケット処理

ソケットディスクリプタ

ドメイン、タイプ、プロトコル、ソケットディスクリプタ、ソケットアドレス構造体
AF_INET

PF_PACKET


************************************************/


/***********************************************
システムコール＋構造体（カーネルの機能を使用する／デバイスを使用する）

＊ファイルディスクリプタに対する操作
　・ファイルディスクリプタを作成する。
　・ファイルディスクリプタから読み込む。
　・ファイルディスクリプタに書き込む。
　・ファイルディスクリプタを破棄する。
　・ファイルディスクリプタの操作を行う。（ロックとか？）
　・
　・
　・ソケットアドレス構造体。
　・

＊ソケットディスクリプタに対する操作
　・通信のためのendpointを作成する。
　・ソケットに名前を付ける。
　・ソケットに対する接続を受け付ける。
　・ソケット上の接続を待つ。
　・ソケットの接続を行う。
　・ソケットからメッセージを受け取る。
　・ソケットディスクリプタを破棄する。



＊ファイルディスクリプタに対するイベントを待つ
　・ファイルディスクリプタに対するイベントを待つ。
　　int poll(struct pollfd *fds, nfds_t nfds, int timeout);
　　pollfd { int fd; short events; short revents; };
　・
　・
　・
　　
　　
＊プロセスに対する操作
　・子プロセスを作成する。
　・パイプを作成する。
　・プロセスの状態変化を待つ。

＊デバイスに対する操作
　・デバイス (device) を制御する。
　・
　・
　・ネットワークデバイス構造体
　・ALSA構造体
　・Video4Linux構造体
　


＊同期IOの多重化
　・多重化されたI/Oの同期をとる。


＊シグナルに対する操作
　・シグナルを操作する。

************************************************/



/***********************************************
スレッド処理



************************************************/

//////////////////////////////////////////////////////////////////////////////////////////


/***********************************************
パケットキャプチャ

1.RAWソケットを取得する。→デバイス処理
2.RAWソケットにデータ（パケット）があれば読み込む。
3.読み込んだパケットを解析する。→パケット解析処理
4.2に戻る。

************************************************/

/***********************************************
ブリッジ
（ノートの無線と有線での２点間のみのブリッジ）

ポーリング
プログラムで複数のファイルディスクリプタを監視する。
一つ以上のファイルディスクリプタがある種のI/O操作のready状態になるまで待つ。
ready状態とは、対応するI/O操作が停止なしに実行可能な状態になること。

1.RAWソケットを取得する。（有線）→デバイス処理
2.RAWソケットを取得する。（無線）→デバイス処理
3.カーネルのパケット転送機能を無効にする。→デバイス処理
4.？シグナルを無効化する→デバイス処理
5.ポーリングで監視するイベントの設定を行う。
6.ポーリングで監視する。
7.パケットを読み込む。
8.別のインターフェイスに書き込む。
9.6に戻る。

************************************************/

/***********************************************
ルータ
＊

インターネットホストアドレスを、 IPv4表記からネットワークバイトオーダへ変換する。
デバイス情報を取得する。→デバイス処理
1.RAWソケットを取得する。（有線）→デバイス処理
デバイス情報を取得する。→デバイス処理
2.RAWソケットを取得する。（無線）→デバイス処理
3.カーネルのパケット転送機能を無効にする。→デバイス処理
スレッド処理の開始
4.？シグナルを無効化する→デバイス処理

5.ポーリングで監視するイベントの設定を行う。
6.ポーリングで監視する。
7.パケットを読み込む。
8.別のインターフェイスに書き込む。
9.6に戻る。


1.Threadを開始する。


************************************************/


/***********************************************
デバイス処理

＊（RAW）ソケットディスクリプタを作成する。
　・ドメイン＋タイプ＋プロトコルから、RAWソケットを作成する。
　・ネットワークインターフェイスを初期化する。
　・ネットワークデバイス名から、ネットワークインターフェイスインデックスを取得する。
　・ドメイン＋プロトコル＋ネットワークインターフェイスインデックスから、ソケットアドレス設定を設定する。
　・RAWソケット＋ソケットアドレスをバインドする。
　・プロミスキャストフラグ名から、プロミスキャストを設定する。（オプション）
　　＋プロミスキャストフラグ名から、プロミスキャストを取得する。
　　＋プロミスキャストフラグから、ネットワークインターフェイスを設定する。
　・RAWソケットディスクリプタをリターンする。

＊カーネルのパケット転送機能を無効にする。
　・”/proc/sys/net/ipv4/ip_forward”から、ファイルディスクリプタを取得する。
　・ファイルディスクリプタ＋無効化リクエストから、？カーネルを設定する。

＊デバイス情報を取得する。（文字列化してね！）
　・DGRAMソケット←作成←ドメイン、タイプ、プロトコル。
　・ネットワークインターフェイス初期化。
　・ネットワークインターフェイス←設定←ネットワークデバイス名。
　・MACアドレス←取得←リクエスト、DGRAMソケット、ネットワークインターフェイス。
　・ユニキャストアドレス←取得←リクエスト、DGRAMソケット、ネットワークインターフェイス。
　・サブネット←取得←リクエスト、DGRAMソケット、ネットワークインターフェイス。
　・ネットマスク←取得←サブネット。
　・デバイス情報をリターンする。
　
************************************************/


/***********************************************
グローバル変数、構造体、関数

************************************************/


/***********************************************
パケット解析処理

＊読み込んだパケットを解析する。
　・ARP/IP/IPv6パケット←解析←イーサネットパケットヘッダ。
　　＋ARPパケット情報←解析←ARPパケット（イーサネットヘッダのタイプがARP）。
　　＋ICMP/TCP/UDPパケット←解析←IPパケット（イーサネットヘッダのタイプがIP）。
　　　−ICMPパケット情報←解析←ICMPパケット（IPヘッダのプロトコルがICMP）。
　　　−TCPパケット情報←解析←TCPパケット（IPヘッダのプロトコルがTCP）。
　　　−UDPパケット情報←解析←UDPパケット（IPヘッダのプロトコルがUDP）。
　　＋ICMP/TCP/UDPパケット←IPv6パケット（イーサネットヘッダのタイプがIPv6）。
　・終了フラグをリターンする。

＊共通解析処理。
　・タイプ種別←解析←パケットヘッダ。
　・パケット←タイプのヘッダ削除←パケットヘッダ。
　・プロトコル種別←解析←パケットヘッダ。
　・パケット情報←解析←パケット。
　・終了フラグをリターンする。（情報を表示／保存する）
　
************************************************/


/***********************************************
表示（コマンドライン、ファイル）

************************************************/


#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <sys/ioctl.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <linux/if.h>

#include <net/ethernet.h>
#include <netpacket/packet.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>

#include <netinet/ip6.h>
#include <netinet/ip_icmp.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#include "netutils.h"
#include "analyze.h"


/*
 * 
 * 
 * "Domain" 		= PF_PACKET
 * 		"Socket Address" = struct sockaddr_ll
 * "Type" 		= SOCK_RAW
 * "Protocol" 	= ETH_P_IP, ETH_P_ALL
 * "Interface" 
 * "Promiss Cast" = NO, OFF
 *
 */



int main() {

	int sockfd;
	int size;
	u_char buf[65535];

	if((sockfd=init_raw_socket("eth1")) == -1) {
		debug_printf("error init %d %d\n", sockfd, sockfd);
		return(-1);
	}

/*	get_ether_info() {
	}*/
	
	while (1) {
		if((size=read(sockfd, buf, sizeof(buf))) <= 0) perror("read()");		
		analyze_packet(buf, size);
	}

	close(sockfd);
	return(0);

}

